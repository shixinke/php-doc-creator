{
  "object": {
    "name": "RedisX"
  },
  "comment": "php redis extension",
  "namespace": "",
  "consts": {
    "AFTER": {
      "comment": null,
      "type": "unknown",
      "value": "after"
    },
    "BEFORE": {
      "comment": null,
      "type": "unknown",
      "value": "before"
    },
    "OPT_SERIALIZER": {
      "comment": null,
      "type": "unknown",
      "value": 1
    },
    "OPT_PREFIX": {
      "comment": null,
      "type": "unknown",
      "value": 2
    },
    "OPT_READ_TIMEOUT": {
      "comment": null,
      "type": "unknown",
      "value": 3
    },
    "OPT_SCAN": {
      "comment": null,
      "type": "unknown",
      "value": 4
    },
    "OPT_SLAVE_FAILOVER": {
      "comment": null,
      "type": "unknown",
      "value": 5
    },
    "FAILOVER_NONE": {
      "comment": null,
      "type": "unknown",
      "value": 0
    },
    "FAILOVER_ERROR": {
      "comment": null,
      "type": "unknown",
      "value": 1
    },
    "FAILOVER_DISTRIBUTE": {
      "comment": null,
      "type": "unknown",
      "value": 2
    },
    "SCAN_NORETRY": {
      "comment": null,
      "type": "unknown",
      "value": 0
    },
    "SCAN_RETRY": {
      "comment": null,
      "type": "unknown",
      "value": 1
    },
    "SERIALIZER_NONE": {
      "comment": null,
      "type": "unknown",
      "value": 0
    },
    "SERIALIZER_PHP": {
      "comment": null,
      "type": "unknown",
      "value": 1
    },
    "SERIALIZER_IGBINARY": {
      "comment": null,
      "type": "unknown",
      "value": 2
    },
    "ATOMIC": {
      "comment": null,
      "type": "unknown",
      "value": 0
    },
    "MULTI": {
      "comment": null,
      "type": "unknown",
      "value": 1
    },
    "PIPELINE": {
      "comment": null,
      "type": "unknown",
      "value": 2
    },
    "REDIS_NOT_FOUND": {
      "comment": null,
      "type": "unknown",
      "value": 0
    },
    "REDIS_STRING": {
      "comment": null,
      "type": "unknown",
      "value": 1
    },
    "REDIS_SET": {
      "comment": null,
      "type": "unknown",
      "value": 2
    },
    "REDIS_LIST": {
      "comment": null,
      "type": "unknown",
      "value": 3
    },
    "REDIS_ZSET": {
      "comment": null,
      "type": "unknown",
      "value": 4
    },
    "REDIS_HASH": {
      "comment": null,
      "type": "unknown",
      "value": 5
    }
  },
  "properties": [],
  "methods": {
    "__construct": {
      "access": "public",
      "comment": "Creates a Redis client",
      "isStatic": false,
      "return": "",
      "example": "$redis = new Redis();",
      "parameters": []
    },
    "connect": {
      "access": "public",
      "comment": "Connects to a Redis instance.",
      "isStatic": false,
      "return": "bool",
      "example": "\n<pre>\n$redis->connect('127.0.0.1', 6379);\n$redis->connect('127.0.0.1');            \/\/ port 6379 by default\n$redis->connect('127.0.0.1', 6379, 2.5); \/\/ 2.5 sec timeout.\n$redis->connect('\/tmp\/redis.sock');      \/\/ unix domain socket.\n<\/pre>",
      "parameters": {
        "host": {
          "comment": "can be a host, or the path to a unix domain socket",
          "type": "string",
          "options": []
        },
        "port": {
          "comment": "optional",
          "type": "int",
          "options": [],
          "value": 6379
        },
        "timeout": {
          "comment": "value in seconds (optional, default is 0.0 meaning unlimited)",
          "type": "float",
          "options": [],
          "value": 0
        },
        "reserved": {
          "comment": "should be  if $retry_interval is specified",
          "type": "null",
          "options": [],
          "value": null
        },
        "retry_interval": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": 0
        },
        "retry_erval": {
          "type": "int",
          "comment": "retry erval in milliseconds."
        }
      }
    },
    "isConnected": {
      "access": "public",
      "comment": "A method to determine if a phpredis object thinks it's connected to a server",
      "isStatic": false,
      "return": "bool",
      "example": "",
      "parameters": []
    },
    "open": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "host": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "port": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": 6379
        },
        "timeout": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": 0
        },
        "reserved": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "retry_interval": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": 0
        },
        "": {
          "type": "int",
          "comment": "retry_erval"
        }
      }
    },
    "pconnect": {
      "access": "public",
      "comment": "Connects to a Redis instance or reuse a connection already established with pconnect\/popen.",
      "isStatic": false,
      "return": "bool",
      "example": "\n<pre>\n$redis->connect('127.0.0.1', 6379);\n$redis->connect('127.0.0.1');            \/\/ port 6379 by default\n$redis->connect('127.0.0.1', 6379, 2.5); \/\/ 2.5 sec timeout.\n$redis->connect('\/tmp\/redis.sock');      \/\/ unix domain socket.\n<\/pre>",
      "parameters": {
        "host": {
          "comment": "can be a host, or the path to a unix domain socket",
          "type": "string",
          "options": []
        },
        "port": {
          "comment": "optional",
          "type": "int",
          "options": [],
          "value": 6379
        },
        "timeout": {
          "comment": "value in seconds (optional, default is 0 meaning unlimited)",
          "type": "float",
          "options": [],
          "value": 0
        },
        "persistent_id": {
          "comment": "unique identifier  for the connection",
          "type": "string",
          "options": [],
          "value": ""
        },
        "retry_interval": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": 0
        },
        "retry_erval": {
          "type": "int",
          "comment": "retry time in milliseconds"
        }
      }
    },
    "popen": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "host": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "port": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": 6379
        },
        "timeout": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": 0
        },
        "persistent_id": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": ""
        },
        "retry_interval": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": 0
        },
        "": {
          "type": "int",
          "comment": "retry_erval"
        }
      }
    },
    "close": {
      "access": "public",
      "comment": "Disconnects from the Redis instance, except when pconnect is used.",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": []
    },
    "setOption": {
      "access": "public",
      "comment": "Set client option.",
      "isStatic": false,
      "return": "bool:",
      "example": "\n<pre>\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_NONE);        \/\/ don't serialize data\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP);         \/\/ use built-in serialize\/unserialize\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_IGBINARY);    \/\/ use igBinary serialize\/unserialize\n$redis->setOption(Redis::OPT_PREFIX, 'myAppName:');                      \/\/ use custom prefix on all keys\n<\/pre>",
      "parameters": {
        "name": {
          "comment": "parameter name",
          "type": "string",
          "options": []
        },
        "value": {
          "comment": "parameter value",
          "type": "string",
          "options": []
        }
      }
    },
    "getOption": {
      "access": "public",
      "comment": "Get client option",
      "isStatic": false,
      "return": "int",
      "example": "\n\/\/ return Redis::SERIALIZER_NONE, Redis::SERIALIZER_PHP, or Redis::SERIALIZER_IGBINARY.\n$redis->getOption(Redis::OPT_SERIALIZER);",
      "parameters": {
        "name": {
          "comment": "parameter name",
          "type": "string",
          "options": []
        }
      }
    },
    "ping": {
      "access": "public",
      "comment": "Check the current connection status",
      "isStatic": false,
      "return": "string",
      "example": "",
      "parameters": []
    },
    "get": {
      "access": "public",
      "comment": "Get the value related to the specified key",
      "isStatic": false,
      "return": "string|bool:",
      "example": "$redis->get('key');",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "set": {
      "access": "public",
      "comment": "Set the string value in argument as value of the key.",
      "isStatic": false,
      "return": "bool",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "timeout": {
          "comment": "If you pass an integer, phpredis will redirect to SETEX, and will try to use Redis >= 2.6.12 extended options if you pass an array with valid values",
          "type": "int|array",
          "options": [],
          "value": null
        },
        "": {
          "type": "string",
          "comment": "value"
        }
      }
    },
    "setex": {
      "access": "public",
      "comment": "Set the string value in argument as value of the key, with a time to live.",
      "isStatic": false,
      "return": "bool:",
      "example": "$redis->setex('key', 3600, 'value'); \/\/ sets key \u2192 value, with 1h TTL.",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "ttl": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "value"
        }
      }
    },
    "setnx": {
      "access": "public",
      "comment": "Set the string value in argument as value of the key if the key doesn't already exist in the database.",
      "isStatic": false,
      "return": "bool:",
      "example": "\n<pre>\n$redis->setnx('key', 'value');   \/\/ return TRUE\n$redis->setnx('key', 'value');   \/\/ return FALSE\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "value"
        }
      }
    },
    "del": {
      "access": "public",
      "comment": "Remove specified keys.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->set('key1', 'val1');\n$redis->set('key2', 'val2');\n$redis->set('key3', 'val3');\n$redis->set('key4', 'val4');\n$redis->delete('key1', 'key2');          \/\/ return 2\n$redis->delete(array('key3', 'key4'));   \/\/ return 2\n<\/pre>",
      "parameters": {
        "key1": {
          "comment": "An array of keys, or an undefined number of parameters, each a key: key1 key2 key3 ... keyN",
          "type": "int|array",
          "options": []
        },
        "key2": {
          "comment": "...",
          "type": "string",
          "options": [],
          "value": null
        },
        "key3": {
          "comment": "...",
          "type": "string",
          "options": [],
          "value": null
        }
      }
    },
    "delete": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "int",
      "example": "",
      "parameters": {
        "key1": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "key2": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "key3": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "": {
          "type": "string",
          "comment": "key3"
        }
      }
    },
    "multi": {
      "access": "public",
      "comment": "Enter and exit transactional mode.",
      "isStatic": false,
      "return": "Once",
      "example": "\n<pre>\n$ret = $redis->multi()\n->set('key1', 'val1')\n->get('key1')\n->set('key2', 'val2')\n->get('key2')\n->exec();\n\/\/$ret == array (\n\/\/    0 => TRUE,\n\/\/    1 => 'val1',\n\/\/    2 => TRUE,\n\/\/    3 => 'val2');\n<\/pre>",
      "parameters": {
        "mode": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": 1
        },
        "": {
          "type": "int",
          "comment": "edis::MULTI|Redis::PIPELINE"
        }
      }
    },
    "exec": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": []
    },
    "discard": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": []
    },
    "watch": {
      "access": "public",
      "comment": "Watches a key for modifications by another client. If the key is modified between WATCH and EXEC,\nthe MULTI\/EXEC transaction will fail (return FALSE). unwatch cancels all the watching of all keys by this client.",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis->watch('x');\n\/\/ long code here during the execution of which other clients could well modify `x`\n$ret = $redis->multi()\n->incr('x')\n->exec();\n\/\/ $ret = FALSE if x has been modified between the call to WATCH and the call to EXEC.\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "|": {
          "type": "string",
          "comment": "array $key: a list of keys"
        }
      }
    },
    "unwatch": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": []
    },
    "subscribe": {
      "access": "public",
      "comment": "Subscribe to channels. Warning: this function will probably change in the future.",
      "isStatic": false,
      "return": "mixed",
      "example": "\n<pre>\nfunction f($redis, $chan, $msg) {\nswitch($chan) {\ncase 'chan-1':\n...\nbreak;\ncase 'chan-2':\n...\nbreak;\ncase 'chan-2':\n...\nbreak;\n}\n}\n$redis->subscribe(array('chan-1', 'chan-2', 'chan-3'), 'f'); \/\/ subscribe to 3 chans\n<\/pre>",
      "parameters": {
        "channels": {
          "comment": "an  of channels to subscribe to",
          "type": "array",
          "options": []
        },
        "callback": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "|": {
          "type": "string",
          "comment": "array    $callback either a  or an array($instance, 'method_name')."
        }
      }
    },
    "psubscribe": {
      "access": "public",
      "comment": "Subscribe to channels by pattern",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\nfunction psubscribe($redis, $pattern, $chan, $msg) {\necho \"Pattern: $pattern\\n\";\necho \"Channel: $chan\\n\";\necho \"Payload: $msg\\n\";\n}\n<\/pre>",
      "parameters": {
        "patterns": {
          "comment": "The number of elements removed from the set.",
          "type": "array",
          "options": []
        },
        "callback": {
          "comment": "Either a string or an array with an object and method.",
          "type": "string|array",
          "options": []
        },
        "Any": {
          "type": "mixed",
          "comment": "non-null return value in the callback will be returned to the caller."
        }
      }
    },
    "publish": {
      "access": "public",
      "comment": "Publish messages to channels. Warning: this function will probably change in the future.",
      "isStatic": false,
      "return": "int",
      "example": "$redis->publish('chan-1', 'hello, world!'); \/\/ send message.",
      "parameters": {
        "channel": {
          "comment": "a channel to publish to",
          "type": "string",
          "options": []
        },
        "message": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "message"
        }
      }
    },
    "pubsub": {
      "access": "public",
      "comment": "A command allowing you to get information on the Redis pub\/sub system.",
      "isStatic": false,
      "return": "-",
      "example": "\n<pre>\n$redis->pubsub('channels'); \/\/ All channels\n$redis->pubsub('channels', '*pattern*'); \/\/ Just channels matching your pattern\n$redis->pubsub('numsub', array('chan1', 'chan2')); \/\/ Get subscriber counts for 'chan1' and 'chan2'\n$redis->pubsub('numpat'); \/\/ Get the number of pattern subscribers\n<\/pre>",
      "parameters": {
        "keyword": {
          "comment": "String, which can be: \"channels\", \"numsub\", or \"numpat\"",
          "type": "string",
          "options": []
        },
        "argument": {
          "comment": "Optional, variant.",
          "type": "string|array",
          "options": []
        }
      }
    },
    "exists": {
      "access": "public",
      "comment": "Verify if the specified key exists.",
      "isStatic": false,
      "return": "bool:",
      "example": "\n<pre>\n$redis->set('key', 'value');\n$redis->exists('key');               \/\/  TRUE\n$redis->exists('NonExistingKey');    \/\/ FALSE\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "incr": {
      "access": "public",
      "comment": "Increment the number stored at key by one.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->incr('key1'); \/\/ key1 didn't exists, set to 0 before the increment and now has the value 1\n$redis->incr('key1'); \/\/ 2\n$redis->incr('key1'); \/\/ 3\n$redis->incr('key1'); \/\/ 4\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "incrByFloat": {
      "access": "public",
      "comment": "Increment the float value of a key by the given amount",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis = new Redis();\n$redis->connect('127.0.0.1');\n$redis->set('x', 3);\nvar_dump( $redis->incrByFloat('x', 1.5) );   \/\/ float(4.5)\n\/\/ ! SIC\nvar_dump( $redis->get('x') );                \/\/ string(3) \"4.5\"\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "increment": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "float",
          "comment": "increment"
        }
      }
    },
    "incrBy": {
      "access": "public",
      "comment": "Increment the number stored at key by one. If the second argument is filled, it will be used as the integer\nvalue of the increment.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->incr('key1');        \/\/ key1 didn't exists, set to 0 before the increment and now has the value 1\n$redis->incr('key1');        \/\/ 2\n$redis->incr('key1');        \/\/ 3\n$redis->incr('key1');        \/\/ 4\n$redis->incrBy('key1', 10);  \/\/ 14\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "key",
          "type": "string",
          "options": []
        },
        "value": {
          "comment": "value that will be added to key (only for incrBy)",
          "type": "int",
          "options": []
        }
      }
    },
    "decr": {
      "access": "public",
      "comment": "Decrement the number stored at key by one.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->decr('key1'); \/\/ key1 didn't exists, set to 0 before the increment and now has the value -1\n$redis->decr('key1'); \/\/ -2\n$redis->decr('key1'); \/\/ -3\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "decrBy": {
      "access": "public",
      "comment": "Decrement the number stored at key by one. If the second argument is filled, it will be used as the integer\nvalue of the decrement.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->decr('key1');        \/\/ key1 didn't exists, set to 0 before the increment and now has the value -1\n$redis->decr('key1');        \/\/ -2\n$redis->decr('key1');        \/\/ -3\n$redis->decrBy('key1', 10);  \/\/ -13\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "that will be substracted to key (only for decrBy)",
          "type": "int",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "getMultiple": {
      "access": "public",
      "comment": "Get the values of all the specified keys. If one or more keys dont exist, the array will contain FALSE at the\nposition of the key.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$redis->set('key1', 'value1');\n$redis->set('key2', 'value2');\n$redis->set('key3', 'value3');\n$redis->getMultiple(array('key1', 'key2', 'key3')); \/\/ array('value1', 'value2', 'value3');\n$redis->getMultiple(array('key0', 'key1', 'key5')); \/\/ array(`FALSE`, 'value2', `FALSE`);\n<\/pre>",
      "parameters": {
        "keys": {
          "comment": "Array containing the list of the keys",
          "type": "array",
          "options": []
        }
      }
    },
    "lPush": {
      "access": "public",
      "comment": "Adds the string values to the head (left) of the list. Creates the list if the key didn't exist.\nIf the key exists and is not a list, FALSE is returned.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->lPush('l', 'v1', 'v2', 'v3', 'v4')   \/\/ int(4)\nvar_dump( $redis->lRange('l', 0, -1) );\n\/\/\/\/ Output:\n\/\/ array(4) {\n\/\/   [0]=> string(2) \"v4\"\n\/\/   [1]=> string(2) \"v3\"\n\/\/   [2]=> string(2) \"v2\"\n\/\/   [3]=> string(2) \"v1\"\n\/\/ }\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value1": {
          "comment": "String, value to push in key",
          "type": "string",
          "options": []
        },
        "value2": {
          "comment": "Optional",
          "type": "string",
          "options": [],
          "value": null
        },
        "valueN": {
          "comment": "Optional",
          "type": "string",
          "options": [],
          "value": null
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "rPush": {
      "access": "public",
      "comment": "Adds the string values to the tail (right) of the list. Creates the list if the key didn't exist.\nIf the key exists and is not a list, FALSE is returned.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->rPush('l', 'v1', 'v2', 'v3', 'v4');    \/\/ int(4)\nvar_dump( $redis->lRange('l', 0, -1) );\n\/\/\/\/ Output:\n\/\/ array(4) {\n\/\/   [0]=> string(2) \"v1\"\n\/\/   [1]=> string(2) \"v2\"\n\/\/   [2]=> string(2) \"v3\"\n\/\/   [3]=> string(2) \"v4\"\n\/\/ }\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value1": {
          "comment": "String, value to push in key",
          "type": "string",
          "options": []
        },
        "value2": {
          "comment": "Optional",
          "type": "string",
          "options": [],
          "value": null
        },
        "valueN": {
          "comment": "Optional",
          "type": "string",
          "options": [],
          "value": null
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "lPushx": {
      "access": "public",
      "comment": "Adds the string value to the head (left) of the list if the list exists.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->delete('key1');\n$redis->lPushx('key1', 'A');     \/\/ returns 0\n$redis->lPush('key1', 'A');      \/\/ returns 1\n$redis->lPushx('key1', 'B');     \/\/ returns 2\n$redis->lPushx('key1', 'C');     \/\/ returns 3\n\/\/ key1 now points to the following list: [ 'A', 'B', 'C' ]\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "String, value to push in key",
          "type": "string",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "rPushx": {
      "access": "public",
      "comment": "Adds the string value to the tail (right) of the list if the ist exists. FALSE in case of Failure.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->delete('key1');\n$redis->rPushx('key1', 'A'); \/\/ returns 0\n$redis->rPush('key1', 'A'); \/\/ returns 1\n$redis->rPushx('key1', 'B'); \/\/ returns 2\n$redis->rPushx('key1', 'C'); \/\/ returns 3\n\/\/ key1 now points to the following list: [ 'A', 'B', 'C' ]\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "String, value to push in key",
          "type": "string",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "lPop": {
      "access": "public",
      "comment": "Returns and removes the first element of the list.",
      "isStatic": false,
      "return": "string",
      "example": "\n<pre>\n$redis->rPush('key1', 'A');\n$redis->rPush('key1', 'B');\n$redis->rPush('key1', 'C');  \/\/ key1 => [ 'A', 'B', 'C' ]\n$redis->lPop('key1');        \/\/ key1 => [ 'B', 'C' ]\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "rPop": {
      "access": "public",
      "comment": "Returns and removes the last element of the list.",
      "isStatic": false,
      "return": "string",
      "example": "\n<pre>\n$redis->rPush('key1', 'A');\n$redis->rPush('key1', 'B');\n$redis->rPush('key1', 'C');  \/\/ key1 => [ 'A', 'B', 'C' ]\n$redis->rPop('key1');        \/\/ key1 => [ 'A', 'B' ]\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "blPop": {
      "access": "public",
      "comment": "Is a blocking lPop primitive. If at least one of the lists contains at least one element,\nthe element will be popped from the head of the list and returned to the caller.\nIl all the list identified by the keys passed in arguments are empty, blPop will block\nduring the specified timeout until an element is pushed to one of those lists. This element will be popped.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n\/\/ Non blocking feature\n$redis->lPush('key1', 'A');\n$redis->delete('key2');\n$redis->blPop('key1', 'key2', 10); \/\/ array('key1', 'A')\n\/\/ OR\n$redis->blPop(array('key1', 'key2'), 10); \/\/ array('key1', 'A')\n$redis->brPop('key1', 'key2', 10); \/\/ array('key1', 'A')\n\/\/ OR\n$redis->brPop(array('key1', 'key2'), 10); \/\/ array('key1', 'A')\n\/\/ Blocking feature\n\/\/ process 1\n$redis->delete('key1');\n$redis->blPop('key1', 10);\n\/\/ blocking for 10 seconds\n\/\/ process 2\n$redis->lPush('key1', 'A');\n\/\/ process 1\n\/\/ array('key1', 'A') is returned\n<\/pre>",
      "parameters": {
        "keys": {
          "comment": "Array containing the keys of the lists",
          "type": "array",
          "options": []
        },
        "timeout": {
          "comment": "Timeout",
          "type": "int",
          "options": []
        }
      }
    },
    "brPop": {
      "access": "public",
      "comment": "Is a blocking rPop primitive. If at least one of the lists contains at least one element,\nthe element will be popped from the head of the list and returned to the caller.\nIl all the list identified by the keys passed in arguments are empty, brPop will\nblock during the specified timeout until an element is pushed to one of those lists. T\nhis element will be popped.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n\/\/ Non blocking feature\n$redis->lPush('key1', 'A');\n$redis->delete('key2');\n$redis->blPop('key1', 'key2', 10); \/\/ array('key1', 'A')\n\/\/ OR\n$redis->blPop(array('key1', 'key2'), 10); \/\/ array('key1', 'A')\n$redis->brPop('key1', 'key2', 10); \/\/ array('key1', 'A')\n\/\/ OR\n$redis->brPop(array('key1', 'key2'), 10); \/\/ array('key1', 'A')\n\/\/ Blocking feature\n\/\/ process 1\n$redis->delete('key1');\n$redis->blPop('key1', 10);\n\/\/ blocking for 10 seconds\n\/\/ process 2\n$redis->lPush('key1', 'A');\n\/\/ process 1\n\/\/ array('key1', 'A') is returned\n<\/pre>",
      "parameters": {
        "keys": {
          "comment": "Array containing the keys of the lists",
          "type": "array",
          "options": []
        },
        "timeout": {
          "comment": "Timeout",
          "type": "int",
          "options": []
        }
      }
    },
    "lLen": {
      "access": "public",
      "comment": "Returns the size of a list identified by Key. If the list didn't exist or is empty,\nthe command returns 0. If the data type identified by Key is not a list, the command return FALSE.",
      "isStatic": false,
      "return": "bool",
      "example": "\n<pre>\n$redis->rPush('key1', 'A');\n$redis->rPush('key1', 'B');\n$redis->rPush('key1', 'C');  \/\/ key1 => [ 'A', 'B', 'C' ]\n$redis->lLen('key1');       \/\/ 3\n$redis->rPop('key1');\n$redis->lLen('key1');       \/\/ 2\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "lSize": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "lIndex": {
      "access": "public",
      "comment": "Return the specified element of the list stored at the specified key.\n0 the first element, 1 the second ... -1 the last element, -2 the penultimate ...\nReturn FALSE in case of a bad index or a key that doesn't point to a list.",
      "isStatic": false,
      "return": "Bool",
      "example": "\n<pre>\n$redis->rPush('key1', 'A');\n$redis->rPush('key1', 'B');\n$redis->rPush('key1', 'C');  \/\/ key1 => [ 'A', 'B', 'C' ]\n$redis->lGet('key1', 0);     \/\/ 'A'\n$redis->lGet('key1', -1);    \/\/ 'C'\n$redis->lGet('key1', 10);    \/\/ `FALSE`\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "index": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "index"
        }
      }
    },
    "lGet": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "index": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "index"
        }
      }
    },
    "lSet": {
      "access": "public",
      "comment": "Set the list at index with the new value.",
      "isStatic": false,
      "return": "is",
      "example": "\n<pre>\n$redis->rPush('key1', 'A');\n$redis->rPush('key1', 'B');\n$redis->rPush('key1', 'C');  \/\/ key1 => [ 'A', 'B', 'C' ]\n$redis->lGet('key1', 0);     \/\/ 'A'\n$redis->lSet('key1', 0, 'X');\n$redis->lGet('key1', 0);     \/\/ 'X'\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "index": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "value"
        }
      }
    },
    "lRange": {
      "access": "public",
      "comment": "Returns the specified elements of the list stored at the specified key in\nthe range [start, end]. start and stop are interpretated as indices: 0 the first element,\n1 the second ... -1 the last element, -2 the penultimate ...",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$redis->rPush('key1', 'A');\n$redis->rPush('key1', 'B');\n$redis->rPush('key1', 'C');\n$redis->lRange('key1', 0, -1); \/\/ array('A', 'B', 'C')\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "end": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "end"
        }
      }
    },
    "lGetRange": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "end": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "end"
        }
      }
    },
    "lTrim": {
      "access": "public",
      "comment": "Trims an existing list so that it will contain only a specified range of elements.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$redis->rPush('key1', 'A');\n$redis->rPush('key1', 'B');\n$redis->rPush('key1', 'C');\n$redis->lRange('key1', 0, -1); \/\/ array('A', 'B', 'C')\n$redis->lTrim('key1', 0, 1);\n$redis->lRange('key1', 0, -1); \/\/ array('A', 'B')\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "stop": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "stop"
        }
      }
    },
    "listTrim": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "stop": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "stop"
        }
      }
    },
    "lRem": {
      "access": "public",
      "comment": "Removes the first count occurences of the value element from the list.\nIf count is zero, all the matching elements are removed. If count is negative,\nelements are removed from tail to head.",
      "isStatic": false,
      "return": "bool",
      "example": "\n<pre>\n$redis->lPush('key1', 'A');\n$redis->lPush('key1', 'B');\n$redis->lPush('key1', 'C');\n$redis->lPush('key1', 'A');\n$redis->lPush('key1', 'A');\n$redis->lRange('key1', 0, -1);   \/\/ array('A', 'A', 'C', 'B', 'A')\n$redis->lRem('key1', 'A', 2);    \/\/ 2\n$redis->lRange('key1', 0, -1);   \/\/ array('C', 'B', 'A')\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "count": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "count"
        }
      }
    },
    "lRemove": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "count": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "count"
        }
      }
    },
    "lInsert": {
      "access": "public",
      "comment": "Insert value in the list before or after the pivot value. the parameter options\nspecify the position of the insert (before or after). If the list didn't exists,\nor the pivot didn't exists, the value is not inserted.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->delete('key1');\n$redis->lInsert('key1', Redis::AFTER, 'A', 'X');     \/\/ 0\n$redis->lPush('key1', 'A');\n$redis->lPush('key1', 'B');\n$redis->lPush('key1', 'C');\n$redis->lInsert('key1', Redis::BEFORE, 'C', 'X');    \/\/ 4\n$redis->lRange('key1', 0, -1);                       \/\/ array('A', 'B', 'X', 'C')\n$redis->lInsert('key1', Redis::AFTER, 'C', 'Y');     \/\/ 5\n$redis->lRange('key1', 0, -1);                       \/\/ array('A', 'B', 'X', 'C', 'Y')\n$redis->lInsert('key1', Redis::AFTER, 'W', 'value'); \/\/ -1\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "position": {
          "comment": "Redis::BEFORE | Redis::AFTER",
          "type": "int",
          "options": []
        },
        "pivot": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "value"
        }
      }
    },
    "sAdd": {
      "access": "public",
      "comment": "Adds a values to the set value stored at key.\nIf this value is already in the set, FALSE is returned.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->sAdd('k', 'v1');                \/\/ int(1)\n$redis->sAdd('k', 'v1', 'v2', 'v3');    \/\/ int(2)\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "Required key",
          "type": "string",
          "options": []
        },
        "value1": {
          "comment": "Required value",
          "type": "string",
          "options": []
        },
        "value2": {
          "comment": "Optional value",
          "type": "string",
          "options": [],
          "value": null
        },
        "valueN": {
          "comment": "Optional value",
          "type": "string",
          "options": [],
          "value": null
        }
      }
    },
    "sRem": {
      "access": "public",
      "comment": "Removes the specified members from the set value stored at key.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\nvar_dump( $redis->sAdd('k', 'v1', 'v2', 'v3') );    \/\/ int(3)\nvar_dump( $redis->sRem('k', 'v2', 'v3') );          \/\/ int(2)\nvar_dump( $redis->sMembers('k') );\n\/\/\/\/ Output:\n\/\/ array(1) {\n\/\/   [0]=> string(2) \"v1\"\n\/\/ }\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "member1": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "member2": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "memberN": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "": {
          "type": "string",
          "comment": "memberN"
        }
      }
    },
    "sRemove": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "member1": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "member2": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "memberN": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "": {
          "type": "string",
          "comment": "memberN"
        }
      }
    },
    "sMove": {
      "access": "public",
      "comment": "Moves the specified member from the set at srcKey to the set at dstKey.",
      "isStatic": false,
      "return": "If",
      "example": "\n<pre>\n$redis->sAdd('key1' , 'set11');\n$redis->sAdd('key1' , 'set12');\n$redis->sAdd('key1' , 'set13');          \/\/ 'key1' => {'set11', 'set12', 'set13'}\n$redis->sAdd('key2' , 'set21');\n$redis->sAdd('key2' , 'set22');          \/\/ 'key2' => {'set21', 'set22'}\n$redis->sMove('key1', 'key2', 'set13');  \/\/ 'key1' =>  {'set11', 'set12'}\n\/\/ 'key2' =>  {'set21', 'set22', 'set13'}\n<\/pre>",
      "parameters": {
        "srcKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "dstKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "member": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "member"
        }
      }
    },
    "sIsMember": {
      "access": "public",
      "comment": "Checks if value is a member of the set stored at the key key.",
      "isStatic": false,
      "return": "bool",
      "example": "\n<pre>\n$redis->sAdd('key1' , 'set1');\n$redis->sAdd('key1' , 'set2');\n$redis->sAdd('key1' , 'set3'); \/\/ 'key1' => {'set1', 'set2', 'set3'}\n$redis->sIsMember('key1', 'set1'); \/\/ TRUE\n$redis->sIsMember('key1', 'setX'); \/\/ FALSE\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "value"
        }
      }
    },
    "sContains": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "value"
        }
      }
    },
    "sCard": {
      "access": "public",
      "comment": "Returns the cardinality of the set identified by key.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->sAdd('key1' , 'set1');\n$redis->sAdd('key1' , 'set2');\n$redis->sAdd('key1' , 'set3');   \/\/ 'key1' => {'set1', 'set2', 'set3'}\n$redis->sCard('key1');           \/\/ 3\n$redis->sCard('keyX');           \/\/ 0\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "sPop": {
      "access": "public",
      "comment": "Removes and returns a random element from the set value at Key.",
      "isStatic": false,
      "return": "bool",
      "example": "\n<pre>\n$redis->sAdd('key1' , 'set1');\n$redis->sAdd('key1' , 'set2');\n$redis->sAdd('key1' , 'set3');   \/\/ 'key1' => {'set3', 'set1', 'set2'}\n$redis->sPop('key1');            \/\/ 'set1', 'key1' => {'set3', 'set2'}\n$redis->sPop('key1');            \/\/ 'set3', 'key1' => {'set2'}\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "sRandMember": {
      "access": "public",
      "comment": "Returns a random element(s) from the set value at Key, without removing it.",
      "isStatic": false,
      "return": "bool",
      "example": "\n<pre>\n$redis->sAdd('key1' , 'one');\n$redis->sAdd('key1' , 'two');\n$redis->sAdd('key1' , 'three');              \/\/ 'key1' => {'one', 'two', 'three'}\nvar_dump( $redis->sRandMember('key1') );     \/\/ 'key1' => {'one', 'two', 'three'}\n\/\/ string(5) \"three\"\nvar_dump( $redis->sRandMember('key1', 2) );  \/\/ 'key1' => {'one', 'two', 'three'}\n\/\/ array(2) {\n\/\/   [0]=> string(2) \"one\"\n\/\/   [1]=> string(2) \"three\"\n\/\/ }\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "count": {
          "comment": "[optional]",
          "type": "int",
          "options": [],
          "value": null
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "sInter": {
      "access": "public",
      "comment": "Returns the members of a set resulting from the intersection of all the sets\nheld at the specified keys. If just a single key is specified, then this command\nproduces the members of this set. If one of the keys is missing, FALSE is returned.",
      "isStatic": false,
      "return": "If",
      "example": "\n<pre>\n$redis->sAdd('key1', 'val1');\n$redis->sAdd('key1', 'val2');\n$redis->sAdd('key1', 'val3');\n$redis->sAdd('key1', 'val4');\n$redis->sAdd('key2', 'val3');\n$redis->sAdd('key2', 'val4');\n$redis->sAdd('key3', 'val3');\n$redis->sAdd('key3', 'val4');\nvar_dump($redis->sInter('key1', 'key2', 'key3'));\n\/\/array(2) {\n\/\/  [0]=>\n\/\/  string(4) \"val4\"\n\/\/  [1]=>\n\/\/  string(4) \"val3\"\n\/\/}\n<\/pre>",
      "parameters": {
        "key1": {
          "comment": "keys identifying the different sets on which we will apply the intersection.",
          "type": "string",
          "options": []
        },
        "key2": {
          "comment": "...",
          "type": "string",
          "options": []
        },
        "keyN": {
          "comment": "...",
          "type": "string",
          "options": [],
          "value": null
        }
      }
    },
    "sInterStore": {
      "access": "public",
      "comment": "Performs a sInter command and stores the result in a new set.",
      "isStatic": false,
      "return": "int:",
      "example": "\n<pre>\n$redis->sAdd('key1', 'val1');\n$redis->sAdd('key1', 'val2');\n$redis->sAdd('key1', 'val3');\n$redis->sAdd('key1', 'val4');\n$redis->sAdd('key2', 'val3');\n$redis->sAdd('key2', 'val4');\n$redis->sAdd('key3', 'val3');\n$redis->sAdd('key3', 'val4');\nvar_dump($redis->sInterStore('output', 'key1', 'key2', 'key3'));\nvar_dump($redis->sMembers('output'));\n\/\/int(2)\n\/\/\n\/\/array(2) {\n\/\/  [0]=>\n\/\/  string(4) \"val4\"\n\/\/  [1]=>\n\/\/  string(4) \"val3\"\n\/\/}\n<\/pre>",
      "parameters": {
        "dstKey": {
          "comment": "the key to store the diff into.",
          "type": "string",
          "options": []
        },
        "key1": {
          "comment": "are intersected as in sInter.",
          "type": "string",
          "options": []
        },
        "key2": {
          "comment": "...",
          "type": "string",
          "options": []
        },
        "keyN": {
          "comment": "...",
          "type": "string",
          "options": [],
          "value": null
        }
      }
    },
    "sUnion": {
      "access": "public",
      "comment": "Performs the union between N sets and returns it.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$redis->delete('s0', 's1', 's2');\n$redis->sAdd('s0', '1');\n$redis->sAdd('s0', '2');\n$redis->sAdd('s1', '3');\n$redis->sAdd('s1', '1');\n$redis->sAdd('s2', '3');\n$redis->sAdd('s2', '4');\nvar_dump($redis->sUnion('s0', 's1', 's2'));\narray(4) {\n\/\/  [0]=>\n\/\/  string(1) \"3\"\n\/\/  [1]=>\n\/\/  string(1) \"4\"\n\/\/  [2]=>\n\/\/  string(1) \"1\"\n\/\/  [3]=>\n\/\/  string(1) \"2\"\n\/\/}\n<\/pre>",
      "parameters": {
        "key1": {
          "comment": "Any number of keys corresponding to sets in redis.",
          "type": "string",
          "options": []
        },
        "key2": {
          "comment": "...",
          "type": "string",
          "options": []
        },
        "keyN": {
          "comment": "...",
          "type": "string",
          "options": [],
          "value": null
        }
      }
    },
    "sUnionStore": {
      "access": "public",
      "comment": "Performs the same action as sUnion, but stores the result in the first key",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->delete('s0', 's1', 's2');\n$redis->sAdd('s0', '1');\n$redis->sAdd('s0', '2');\n$redis->sAdd('s1', '3');\n$redis->sAdd('s1', '1');\n$redis->sAdd('s2', '3');\n$redis->sAdd('s2', '4');\nvar_dump($redis->sUnionStore('dst', 's0', 's1', 's2'));\nvar_dump($redis->sMembers('dst'));\n\/\/int(4)\n\/\/array(4) {\n\/\/  [0]=>\n\/\/  string(1) \"3\"\n\/\/  [1]=>\n\/\/  string(1) \"4\"\n\/\/  [2]=>\n\/\/  string(1) \"1\"\n\/\/  [3]=>\n\/\/  string(1) \"2\"\n\/\/}\n<\/pre>",
      "parameters": {
        "dstKey": {
          "comment": "the key to store the diff into.",
          "type": "string",
          "options": []
        },
        "key1": {
          "comment": "Any number of keys corresponding to sets in redis.",
          "type": "string",
          "options": []
        },
        "key2": {
          "comment": "...",
          "type": "string",
          "options": []
        },
        "keyN": {
          "comment": "...",
          "type": "string",
          "options": [],
          "value": null
        }
      }
    },
    "sDiff": {
      "access": "public",
      "comment": "Performs the difference between N sets and returns it.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$redis->delete('s0', 's1', 's2');\n$redis->sAdd('s0', '1');\n$redis->sAdd('s0', '2');\n$redis->sAdd('s0', '3');\n$redis->sAdd('s0', '4');\n$redis->sAdd('s1', '1');\n$redis->sAdd('s2', '3');\nvar_dump($redis->sDiff('s0', 's1', 's2'));\n\/\/array(2) {\n\/\/  [0]=>\n\/\/  string(1) \"4\"\n\/\/  [1]=>\n\/\/  string(1) \"2\"\n\/\/}\n<\/pre>",
      "parameters": {
        "key1": {
          "comment": "Any number of keys corresponding to sets in redis.",
          "type": "string",
          "options": []
        },
        "key2": {
          "comment": "...",
          "type": "string",
          "options": []
        },
        "keyN": {
          "comment": "...",
          "type": "string",
          "options": [],
          "value": null
        }
      }
    },
    "sDiffStore": {
      "access": "public",
      "comment": "Performs the same action as sDiff, but stores the result in the first key",
      "isStatic": false,
      "return": "int:",
      "example": "\n<pre>\n$redis->delete('s0', 's1', 's2');\n$redis->sAdd('s0', '1');\n$redis->sAdd('s0', '2');\n$redis->sAdd('s0', '3');\n$redis->sAdd('s0', '4');\n$redis->sAdd('s1', '1');\n$redis->sAdd('s2', '3');\nvar_dump($redis->sDiffStore('dst', 's0', 's1', 's2'));\nvar_dump($redis->sMembers('dst'));\n\/\/int(2)\n\/\/array(2) {\n\/\/  [0]=>\n\/\/  string(1) \"4\"\n\/\/  [1]=>\n\/\/  string(1) \"2\"\n\/\/}\n<\/pre>",
      "parameters": {
        "dstKey": {
          "comment": "the key to store the diff into.",
          "type": "string",
          "options": []
        },
        "key1": {
          "comment": "Any number of keys corresponding to sets in redis",
          "type": "string",
          "options": []
        },
        "key2": {
          "comment": "...",
          "type": "string",
          "options": []
        },
        "keyN": {
          "comment": "...",
          "type": "string",
          "options": [],
          "value": null
        }
      }
    },
    "sMembers": {
      "access": "public",
      "comment": "Returns the contents of a set.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$redis->delete('s');\n$redis->sAdd('s', 'a');\n$redis->sAdd('s', 'b');\n$redis->sAdd('s', 'a');\n$redis->sAdd('s', 'c');\nvar_dump($redis->sMembers('s'));\n\/\/array(3) {\n\/\/  [0]=>\n\/\/  string(1) \"c\"\n\/\/  [1]=>\n\/\/  string(1) \"a\"\n\/\/  [2]=>\n\/\/  string(1) \"b\"\n\/\/}\n\/\/ The order is random and corresponds to redis' own internal representation of the set structure.\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "sGetMembers": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "array",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "sScan": {
      "access": "public",
      "comment": "Scan a set for members.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$iterator = null;\nwhile ($members = $redis->sScan('set', $iterator)) {\nforeach ($members as $member) {\necho $member . PHP_EOL;\n}\n}\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "The set to search.",
          "type": "string",
          "options": []
        },
        "iterator": {
          "comment": "LONG (reference) to the iterator as we go.",
          "type": "int",
          "options": []
        },
        "pattern": {
          "comment": "String, optional pattern to match against.",
          "type": "null",
          "options": [],
          "value": null
        },
        "count": {
          "comment": "How many members to return at a time (Redis might return a different amount).",
          "type": "int",
          "options": [],
          "value": 0
        }
      }
    },
    "getSet": {
      "access": "public",
      "comment": "Sets a value and returns the previous entry at that key.",
      "isStatic": false,
      "return": "string",
      "example": "\n<pre>\n$redis->set('x', '42');\n$exValue = $redis->getSet('x', 'lol');   \/\/ return '42', replaces x by 'lol'\n$newValue = $redis->get('x')'            \/\/ return 'lol'\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "value"
        }
      }
    },
    "randomKey": {
      "access": "public",
      "comment": "Returns a random key.",
      "isStatic": false,
      "return": "string:",
      "example": "\n<pre>\n$key = $redis->randomKey();\n$surprise = $redis->get($key);  \/\/ who knows what's in there.\n<\/pre>",
      "parameters": []
    },
    "select": {
      "access": "public",
      "comment": "Switches to a given database.",
      "isStatic": false,
      "return": "bool",
      "example": "\n<pre>\n$redis->select(0);       \/\/ switch to DB 0\n$redis->set('x', '42');  \/\/ write 42 to x\n$redis->move('x', 1);    \/\/ move to DB 1\n$redis->select(1);       \/\/ switch to DB 1\n$redis->get('x');        \/\/ will return 42\n<\/pre>",
      "parameters": {
        "dbindex": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "dbindex"
        }
      }
    },
    "move": {
      "access": "public",
      "comment": "Moves a key to a different database.",
      "isStatic": false,
      "return": "bool:",
      "example": "\n<pre>\n$redis->select(0);       \/\/ switch to DB 0\n$redis->set('x', '42');  \/\/ write 42 to x\n$redis->move('x', 1);    \/\/ move to DB 1\n$redis->select(1);       \/\/ switch to DB 1\n$redis->get('x');        \/\/ will return 42\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "dbindex": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "dbindex"
        }
      }
    },
    "rename": {
      "access": "public",
      "comment": "Renames a key.",
      "isStatic": false,
      "return": "bool:",
      "example": "\n<pre>\n$redis->set('x', '42');\n$redis->rename('x', 'y');\n$redis->get('y');   \/\/ \u2192 42\n$redis->get('x');   \/\/ \u2192 `FALSE`\n<\/pre>",
      "parameters": {
        "srcKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "dstKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "dstKey"
        }
      }
    },
    "renameKey": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "srcKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "dstKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "dstKey"
        }
      }
    },
    "renameNx": {
      "access": "public",
      "comment": "Renames a key.",
      "isStatic": false,
      "return": "bool:",
      "example": "\n<pre>\n$redis->set('x', '42');\n$redis->rename('x', 'y');\n$redis->get('y');   \/\/ \u2192 42\n$redis->get('x');   \/\/ \u2192 `FALSE`\n<\/pre>",
      "parameters": {
        "srcKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "dstKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "dstKey"
        }
      }
    },
    "expire": {
      "access": "public",
      "comment": "Sets an expiration date (a timeout) on an item.",
      "isStatic": false,
      "return": "bool:",
      "example": "\n<pre>\n$redis->set('x', '42');\n$redis->setTimeout('x', 3);  \/\/ x will disappear in 3 seconds.\nsleep(5);                    \/\/ wait 5 seconds\n$redis->get('x');            \/\/ will return `FALSE`, as 'x' has expired.\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "The key that will disappear.",
          "type": "string",
          "options": []
        },
        "ttl": {
          "comment": "The key's remaining Time To Live, in seconds.",
          "type": "int",
          "options": []
        }
      }
    },
    "pExpire": {
      "access": "public",
      "comment": "Sets an expiration date (a timeout in milliseconds) on an item.",
      "isStatic": false,
      "return": "bool:",
      "example": "\n<pre>\n$redis->set('x', '42');\n$redis->pExpire('x', 11500); \/\/ x will disappear in 11500 milliseconds.\n$redis->ttl('x');            \/\/ 12\n$redis->pttl('x');           \/\/ 11500\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "The key that will disappear.",
          "type": "string",
          "options": []
        },
        "ttl": {
          "comment": "The key's remaining Time To Live, in milliseconds.",
          "type": "int",
          "options": []
        }
      }
    },
    "setTimeout": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "ttl": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "ttl"
        }
      }
    },
    "expireAt": {
      "access": "public",
      "comment": "Sets an expiration date (a timestamp) on an item.",
      "isStatic": false,
      "return": "bool:",
      "example": "\n<pre>\n$redis->set('x', '42');\n$now = time(NULL);               \/\/ current timestamp\n$redis->expireAt('x', $now + 3); \/\/ x will disappear in 3 seconds.\nsleep(5);                        \/\/ wait 5 seconds\n$redis->get('x');                \/\/ will return `FALSE`, as 'x' has expired.\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "The key that will disappear.",
          "type": "string",
          "options": []
        },
        "timestamp": {
          "comment": "Unix timestamp. The key's date of death, in seconds from Epoch time.",
          "type": "int",
          "options": []
        }
      }
    },
    "pExpireAt": {
      "access": "public",
      "comment": "Sets an expiration date (a timestamp) on an item. Requires a timestamp in milliseconds",
      "isStatic": false,
      "return": "bool:",
      "example": "\n<pre>\n$redis->set('x', '42');\n$redis->pExpireAt('x', 1555555555005);\necho $redis->ttl('x');                       \/\/ 218270121\necho $redis->pttl('x');                      \/\/ 218270120575\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "The key that will disappear.",
          "type": "string",
          "options": []
        },
        "timestamp": {
          "comment": "Unix timestamp. The key's date of death, in seconds from Epoch time.",
          "type": "int",
          "options": []
        }
      }
    },
    "keys": {
      "access": "public",
      "comment": "Returns the keys that match a certain pattern.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$allKeys = $redis->keys('*');   \/\/ all keys will match this.\n$keyWithUserPrefix = $redis->keys('user*');\n<\/pre>",
      "parameters": {
        "pattern": {
          "comment": "pattern, using '*' as a wildcard.",
          "type": "string",
          "options": []
        }
      }
    },
    "getKeys": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "pattern": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "pattern"
        }
      }
    },
    "dbSize": {
      "access": "public",
      "comment": "Returns the current database's size.",
      "isStatic": false,
      "return": "int:",
      "example": "\n<pre>\n$count = $redis->dbSize();\necho \"Redis has $count keys\\n\";\n<\/pre>",
      "parameters": []
    },
    "auth": {
      "access": "public",
      "comment": "Authenticate the connection using a password.\nWarning: The password is sent in plain-text over the network.",
      "isStatic": false,
      "return": "bool:",
      "example": "$redis->auth('foobared');",
      "parameters": {
        "password": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "password"
        }
      }
    },
    "bgrewriteaof": {
      "access": "public",
      "comment": "Starts the background rewrite of AOF (Append-Only File)",
      "isStatic": false,
      "return": "bool:",
      "example": "$redis->bgrewriteaof();",
      "parameters": []
    },
    "slaveof": {
      "access": "public",
      "comment": "Changes the slave status\nEither host and port, or no parameter to stop being a slave.",
      "isStatic": false,
      "return": "bool:",
      "example": "\n<pre>\n$redis->slaveof('10.0.1.7', 6379);\n\/\/ ...\n$redis->slaveof();\n<\/pre>",
      "parameters": {
        "host": {
          "comment": "[optional]",
          "type": "string",
          "options": [],
          "value": "127.0.0.1"
        },
        "port": {
          "comment": "[optional]",
          "type": "int",
          "options": [],
          "value": 6379
        }
      }
    },
    "object": {
      "access": "public",
      "comment": "Describes the object pointed to by a key.\nThe information to retrieve (string) and the key (string).\nInfo can be one of the following:\n- \"encoding\"\n- \"refcount\"\n- \"idletime\"",
      "isStatic": false,
      "return": "string",
      "example": "\n<pre>\n$redis->object(\"encoding\", \"l\"); \/\/ \u2192 ziplist\n$redis->object(\"refcount\", \"l\"); \/\/ \u2192 1\n$redis->object(\"idletime\", \"l\"); \/\/ \u2192 400 (in seconds, with a precision of 10 seconds).\n<\/pre>",
      "parameters": {
        "string": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": ""
        },
        "key": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": ""
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "save": {
      "access": "public",
      "comment": "Performs a synchronous save.",
      "isStatic": false,
      "return": "If",
      "example": "$redis->save();",
      "parameters": []
    },
    "bgsave": {
      "access": "public",
      "comment": "Performs a background save.",
      "isStatic": false,
      "return": "If",
      "example": "$redis->bgSave();",
      "parameters": []
    },
    "lastSave": {
      "access": "public",
      "comment": "Returns the timestamp of the last disk save.",
      "isStatic": false,
      "return": "int:",
      "example": "$redis->lastSave();",
      "parameters": []
    },
    "wait": {
      "access": "public",
      "comment": "Blocks the current client until all the previous write commands are successfully transferred and\nacknowledged by at least the specified number of slaves.",
      "isStatic": false,
      "return": "context",
      "example": "$redis->wait(2, 1000);",
      "parameters": {
        "numSlaves": {
          "comment": "Number of slaves that need to acknowledge previous write commands.",
          "type": "int",
          "options": []
        },
        "timeout": {
          "comment": "Timeout in milliseconds.",
          "type": "int",
          "options": []
        }
      }
    },
    "type": {
      "access": "public",
      "comment": "Returns the type of data pointed by a given key.",
      "isStatic": false,
      "return": "-",
      "example": "$redis->type('key');",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "append": {
      "access": "public",
      "comment": "Append specified string to the string stored in specified key.",
      "isStatic": false,
      "return": "int:",
      "example": "\n<pre>\n$redis->set('key', 'value1');\n$redis->append('key', 'value2'); \/\/ 12\n$redis->get('key');              \/\/ 'value1value2'\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "value"
        }
      }
    },
    "getRange": {
      "access": "public",
      "comment": "Return a substring of a larger string",
      "isStatic": false,
      "return": "string:",
      "example": "\n<pre>\n$redis->set('key', 'string value');\n$redis->getRange('key', 0, 5);   \/\/ 'string'\n$redis->getRange('key', -5, -1); \/\/ 'value'\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "end": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "end"
        }
      }
    },
    "substr": {
      "access": "public",
      "comment": "Return a substring of a larger string",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "end": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "end"
        }
      }
    },
    "setRange": {
      "access": "public",
      "comment": "Changes a substring of a larger string.",
      "isStatic": false,
      "return": "string:",
      "example": "\n<pre>\n$redis->set('key', 'Hello world');\n$redis->setRange('key', 6, \"redis\"); \/\/ returns 11\n$redis->get('key');                  \/\/ \"Hello redis\"\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "offset": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "value"
        }
      }
    },
    "strlen": {
      "access": "public",
      "comment": "Get the length of a string value.",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis->set('key', 'value');\n$redis->strlen('key'); \/\/ 5\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "bitpos": {
      "access": "public",
      "comment": "Return the position of the first bit set to 1 or 0 in a string. The position is returned, thinking of the\nstring as an array of bits from left to right, where the first byte's most significant bit is at position 0,\nthe second byte's most significant bit is at position 8, and so forth.",
      "isStatic": false,
      "return": "function",
      "example": "\n<pre>\n$redis->set('key', '\\xff\\xff');\n$redis->bitpos('key', 1); \/\/ int(0)\n$redis->bitpos('key', 1, 1); \/\/ int(8)\n$redis->bitpos('key', 1, 3); \/\/ int(-1)\n$redis->bitpos('key', 0); \/\/ int(16)\n$redis->bitpos('key', 0, 1); \/\/ int(16)\n$redis->bitpos('key', 0, 1, 5); \/\/ int(-1)\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "bit": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": 0
        },
        "end": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "": {
          "type": "int",
          "comment": "end"
        }
      }
    },
    "getBit": {
      "access": "public",
      "comment": "Return a single bit out of a larger string",
      "isStatic": false,
      "return": "int:",
      "example": "\n<pre>\n$redis->set('key', \"\\x7f\");  \/\/ this is 0111 1111\n$redis->getBit('key', 0);    \/\/ 0\n$redis->getBit('key', 1);    \/\/ 1\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "offset": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "offset"
        }
      }
    },
    "setBit": {
      "access": "public",
      "comment": "Changes a single bit of a string.",
      "isStatic": false,
      "return": "int:",
      "example": "\n<pre>\n$redis->set('key', \"*\");     \/\/ ord(\"*\") = 42 = 0x2f = \"0010 1010\"\n$redis->setBit('key', 5, 1); \/\/ returns 0\n$redis->setBit('key', 7, 1); \/\/ returns 0\n$redis->get('key');          \/\/ chr(0x2f) = \"\/\" = b(\"0010 1111\")\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "offset": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "bool or int (1 or 0)",
          "type": "bool|int",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "offset"
        }
      }
    },
    "bitCount": {
      "access": "public",
      "comment": "Count bits in a string.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->set('bit', '345'); \/\/ \/\/ 11 0011  0011 0100  0011 0101\nvar_dump( $redis->bitCount('bit', 0, 0) ); \/\/ int(4)\nvar_dump( $redis->bitCount('bit', 1, 1) ); \/\/ int(3)\nvar_dump( $redis->bitCount('bit', 2, 2) ); \/\/ int(4)\nvar_dump( $redis->bitCount('bit', 0, 2) ); \/\/ int(11)\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "bitOp": {
      "access": "public",
      "comment": "Bitwise operation on multiple keys.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->set('bit1', '1'); \/\/ 11 0001\n$redis->set('bit2', '2'); \/\/ 11 0010\n$redis->bitOp('AND', 'bit', 'bit1', 'bit2'); \/\/ bit = 110000\n$redis->bitOp('OR',  'bit', 'bit1', 'bit2'); \/\/ bit = 110011\n$redis->bitOp('NOT', 'bit', 'bit1', 'bit2'); \/\/ bit = 110011\n$redis->bitOp('XOR', 'bit', 'bit1', 'bit2'); \/\/ bit = 11\n<\/pre>",
      "parameters": {
        "operation": {
          "comment": "either \"AND\", \"OR\", \"NOT\", \"XOR\"",
          "type": "string",
          "options": []
        },
        "retKey": {
          "comment": "return key",
          "type": "string",
          "options": []
        },
        "key1": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "key2": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "key3": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "": {
          "type": "string",
          "comment": "key3"
        }
      }
    },
    "flushDB": {
      "access": "public",
      "comment": "Removes all entries from the current database.",
      "isStatic": false,
      "return": "bool:",
      "example": "$redis->flushDB();",
      "parameters": []
    },
    "flushAll": {
      "access": "public",
      "comment": "Removes all entries from all databases.",
      "isStatic": false,
      "return": "bool:",
      "example": "$redis->flushAll();",
      "parameters": []
    },
    "sort": {
      "access": "public",
      "comment": "Sort",
      "isStatic": false,
      "return": "An",
      "example": "\n<pre>\n$redis->delete('s');\n$redis->sadd('s', 5);\n$redis->sadd('s', 4);\n$redis->sadd('s', 2);\n$redis->sadd('s', 1);\n$redis->sadd('s', 3);\nvar_dump($redis->sort('s')); \/\/ 1,2,3,4,5\nvar_dump($redis->sort('s', array('sort' => 'desc'))); \/\/ 5,4,3,2,1\nvar_dump($redis->sort('s', array('sort' => 'desc', 'store' => 'out'))); \/\/ (int)5\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "option": {
          "comment": "(key => value, ...) - optional, with the following keys and values:",
          "type": "array",
          "options": [],
          "value": null
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "info": {
      "access": "public",
      "comment": "Returns an associative array of strings and integers",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis->info();\nor\n$redis->info(\"COMMANDSTATS\"); \/\/Information on the commands that have been run (>=2.6 only)\n$redis->info(\"CPU\"); \/\/ just CPU information from Redis INFO\n<\/pre>",
      "parameters": {
        "option": {
          "comment": "Optional. The option to provide redis.",
          "type": "string",
          "options": [],
          "value": null
        }
      }
    },
    "resetStat": {
      "access": "public",
      "comment": "Resets the statistics reported by Redis using the INFO command (`info()` function).\nThese are the counters that are reset:\n- Keyspace hits\n- Keyspace misses\n- Number of commands processed\n- Number of connections received\n- Number of expired keys",
      "isStatic": false,
      "return": "bool:",
      "example": "$redis->resetStat();",
      "parameters": []
    },
    "ttl": {
      "access": "public",
      "comment": "Returns the time to live left for a given key, in seconds. If the key doesn't exist, FALSE is returned.",
      "isStatic": false,
      "return": "int,",
      "example": "$redis->ttl('key');",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "pttl": {
      "access": "public",
      "comment": "Returns a time to live left for a given key, in milliseconds.",
      "isStatic": false,
      "return": "int",
      "example": "$redis->pttl('key');",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "persist": {
      "access": "public",
      "comment": "Remove the expiration timer from a key.",
      "isStatic": false,
      "return": "bool:",
      "example": "$redis->persist('key');",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "mset": {
      "access": "public",
      "comment": "Sets multiple key-value pairs in one atomic command.\nMSETNX only returns TRUE if all the keys were set (see SETNX).",
      "isStatic": false,
      "return": "bool",
      "example": "\n<pre>\n$redis->mset(array('key0' => 'value0', 'key1' => 'value1'));\nvar_dump($redis->get('key0'));\nvar_dump($redis->get('key1'));\n\/\/ Output:\n\/\/ string(6) \"value0\"\n\/\/ string(6) \"value1\"\n<\/pre>",
      "parameters": {
        "array": {
          "comment": "",
          "type": {},
          "options": []
        },
        "=>": {
          "type": "array(key",
          "comment": "value) $array Pairs:  => value, ...)"
        }
      }
    },
    "mget": {
      "access": "public",
      "comment": "Returns the values of all specified keys.",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis->delete('x', 'y', 'z', 'h');\t\/\/ remove x y z\n$redis->mset(array('x' => 'a', 'y' => 'b', 'z' => 'c'));\n$redis->hset('h', 'field', 'value');\nvar_dump($redis->mget(array('x', 'y', 'z', 'h')));\n\/\/ Output:\n\/\/ array(3) {\n\/\/ [0]=>\n\/\/ string(1) \"a\"\n\/\/ [1]=>\n\/\/ string(1) \"b\"\n\/\/ [2]=>\n\/\/ string(1) \"c\"\n\/\/ [3]=>\n\/\/ bool(false)\n\/\/ }\n<\/pre>",
      "parameters": {
        "array": {
          "comment": "",
          "type": {},
          "options": []
        },
        "": {
          "type": "array",
          "comment": ""
        }
      }
    },
    "msetnx": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "int",
      "example": "",
      "parameters": {
        "array": {
          "comment": "",
          "type": {},
          "options": []
        },
        "": {
          "type": "array",
          "comment": ""
        }
      }
    },
    "rpoplpush": {
      "access": "public",
      "comment": "Pops a value from the tail of a list, and pushes it to the front of another list.\nAlso return this value.",
      "isStatic": false,
      "return": "string",
      "example": "\n<pre>\n$redis->delete('x', 'y');\n$redis->lPush('x', 'abc');\n$redis->lPush('x', 'def');\n$redis->lPush('y', '123');\n$redis->lPush('y', '456');\n\/\/ move the last of x to the front of y.\nvar_dump($redis->rpoplpush('x', 'y'));\nvar_dump($redis->lRange('x', 0, -1));\nvar_dump($redis->lRange('y', 0, -1));\n\/\/Output:\n\/\/\n\/\/string(3) \"abc\"\n\/\/array(1) {\n\/\/  [0]=>\n\/\/  string(3) \"def\"\n\/\/}\n\/\/array(3) {\n\/\/  [0]=>\n\/\/  string(3) \"abc\"\n\/\/  [1]=>\n\/\/  string(3) \"456\"\n\/\/  [2]=>\n\/\/  string(3) \"123\"\n\/\/}\n<\/pre>",
      "parameters": {
        "srcKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "dstKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "dstKey"
        }
      }
    },
    "brpoplpush": {
      "access": "public",
      "comment": "A blocking version of rpoplpush, with an integral timeout in the third parameter.",
      "isStatic": false,
      "return": "string",
      "example": "",
      "parameters": {
        "srcKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "dstKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "timeout": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "timeout"
        }
      }
    },
    "zAdd": {
      "access": "public",
      "comment": "Adds the specified member with a given score to the sorted set stored at key.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n<pre>\n$redis->zAdd('z', 1, 'v2', 2, 'v2', 3, 'v3', 4, 'v4' );  \/\/ int(2)\n$redis->zRem('z', 'v2', 'v3');                           \/\/ int(2)\nvar_dump( $redis->zRange('z', 0, -1) );\n\/\/\/\/ Output:\n\/\/ array(2) {\n\/\/   [0]=> string(2) \"v1\"\n\/\/   [1]=> string(2) \"v4\"\n\/\/ }\n<\/pre>\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "Required key",
          "type": "string",
          "options": []
        },
        "score1": {
          "comment": "Required score",
          "type": "float",
          "options": []
        },
        "value1": {
          "comment": "Required value",
          "type": "string",
          "options": []
        },
        "score2": {
          "comment": "Optional score",
          "type": "float",
          "options": [],
          "value": null
        },
        "value2": {
          "comment": "Optional value",
          "type": "string",
          "options": [],
          "value": null
        },
        "scoreN": {
          "comment": "Optional score",
          "type": "float",
          "options": [],
          "value": null
        },
        "valueN": {
          "comment": "Optional value",
          "type": "string",
          "options": [],
          "value": null
        }
      }
    },
    "zRange": {
      "access": "public",
      "comment": "Returns a range of elements from the ordered set stored at the specified key,\nwith values in the range [start, end]. start and stop are interpreted as zero-based indices:\n0 the first element,\n1 the second ...\n-1 the last element,\n-2 the penultimate ...",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$redis->zAdd('key1', 0, 'val0');\n$redis->zAdd('key1', 2, 'val2');\n$redis->zAdd('key1', 10, 'val10');\n$redis->zRange('key1', 0, -1); \/\/ array('val0', 'val2', 'val10')\n\/\/ with scores\n$redis->zRange('key1', 0, -1, true); \/\/ array('val0' => 0, 'val2' => 2, 'val10' => 10)\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "end": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "withscores": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "": {
          "type": "bool",
          "comment": "withscores"
        }
      }
    },
    "zRem": {
      "access": "public",
      "comment": "Deletes a specified member from the ordered set.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->zAdd('z', 1, 'v2', 2, 'v2', 3, 'v3', 4, 'v4' );  \/\/ int(2)\n$redis->zRem('z', 'v2', 'v3');                           \/\/ int(2)\nvar_dump( $redis->zRange('z', 0, -1) );\n\/\/\/\/ Output:\n\/\/ array(2) {\n\/\/   [0]=> string(2) \"v1\"\n\/\/   [1]=> string(2) \"v4\"\n\/\/ }\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "member1": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "member2": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "memberN": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "": {
          "type": "string",
          "comment": "memberN"
        }
      }
    },
    "zDelete": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "int",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "member1": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "member2": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "memberN": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "": {
          "type": "string",
          "comment": "memberN"
        }
      }
    },
    "zRevRange": {
      "access": "public",
      "comment": "Returns the elements of the sorted set stored at the specified key in the range [start, end]\nin reverse order. start and stop are interpretated as zero-based indices:\n0 the first element,\n1 the second ...\n-1 the last element,\n-2 the penultimate ...",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$redis->zAdd('key', 0, 'val0');\n$redis->zAdd('key', 2, 'val2');\n$redis->zAdd('key', 10, 'val10');\n$redis->zRevRange('key', 0, -1); \/\/ array('val10', 'val2', 'val0')\n\/\/ with scores\n$redis->zRevRange('key', 0, -1, true); \/\/ array('val10' => 10, 'val2' => 2, 'val0' => 0)\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "end": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "withscore": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "": {
          "type": "bool",
          "comment": "withscore"
        }
      }
    },
    "zRangeByScore": {
      "access": "public",
      "comment": "Returns the elements of the sorted set stored at the specified key which have scores in the\nrange [start,end]. Adding a parenthesis before start or end excludes it from the range.\n+inf and -inf are also valid limits.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$redis->zAdd('key', 0, 'val0');\n$redis->zAdd('key', 2, 'val2');\n$redis->zAdd('key', 10, 'val10');\n$redis->zRangeByScore('key', 0, 3);                                          \/\/ array('val0', 'val2')\n$redis->zRangeByScore('key', 0, 3, array('withscores' => TRUE);              \/\/ array('val0' => 0, 'val2' => 2)\n$redis->zRangeByScore('key', 0, 3, array('limit' => array(1, 1));                        \/\/ array('val2' => 2)\n$redis->zRangeByScore('key', 0, 3, array('limit' => array(1, 1));                        \/\/ array('val2')\n$redis->zRangeByScore('key', 0, 3, array('withscores' => TRUE, 'limit' => array(1, 1));  \/\/ array('val2' => 2)\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "end": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "options": {
          "comment": "Two options are available:",
          "type": "array",
          "options": [],
          "value": []
        },
        "": {
          "type": "int",
          "comment": "end"
        }
      }
    },
    "zRevRangeByScore": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "end": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "options": {
          "comment": "",
          "type": {},
          "options": [],
          "value": []
        },
        "": {
          "type": "array",
          "comment": "options"
        }
      }
    },
    "zRangeByLex": {
      "access": "public",
      "comment": "Returns a lexigraphical range of members in a sorted set, assuming the members have the same score. The\nmin and max values are required to start with '(' (exclusive), '[' (inclusive), or be exactly the values\n'-' (negative inf) or '+' (positive inf).  The command must be called with either three *or* five\narguments or will return FALSE.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\nforeach (array('a', 'b', 'c', 'd', 'e', 'f', 'g') as $char) {\n$redis->zAdd('key', $char);\n}\n$redis->zRangeByLex('key', '-', '[c'); \/\/ array('a', 'b', 'c')\n$redis->zRangeByLex('key', '-', '(c'); \/\/ array('a', 'b')\n$redis->zRangeByLex('key', '-', '[c'); \/\/ array('b', 'c')\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "The ZSET you wish to run against.",
          "type": "string",
          "options": []
        },
        "min": {
          "comment": "The minimum alphanumeric value you wish to get.",
          "type": "int",
          "options": []
        },
        "max": {
          "comment": "The maximum alphanumeric value you wish to get.",
          "type": "int",
          "options": []
        },
        "offset": {
          "comment": "Optional argument if you wish to start somewhere other than the first element.",
          "type": "int",
          "options": [],
          "value": null
        },
        "limit": {
          "comment": "Optional argument if you wish to limit the number of elements returned.",
          "type": "int",
          "options": [],
          "value": null
        }
      }
    },
    "zRevRangeByLex": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "min": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "max": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "offset": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "limit": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "": {
          "type": "int",
          "comment": "limit"
        }
      }
    },
    "zCount": {
      "access": "public",
      "comment": "Returns the number of elements of the sorted set stored at the specified key which have\nscores in the range [start,end]. Adding a parenthesis before start or end excludes it\nfrom the range. +inf and -inf are also valid limits.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->zAdd('key', 0, 'val0');\n$redis->zAdd('key', 2, 'val2');\n$redis->zAdd('key', 10, 'val10');\n$redis->zCount('key', 0, 3); \/\/ 2, corresponding to array('val0', 'val2')\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "end": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "end"
        }
      }
    },
    "zRemRangeByScore": {
      "access": "public",
      "comment": "Deletes the elements of the sorted set stored at the specified key which have scores in the range [start,end].",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->zAdd('key', 0, 'val0');\n$redis->zAdd('key', 2, 'val2');\n$redis->zAdd('key', 10, 'val10');\n$redis->zRemRangeByScore('key', 0, 3); \/\/ 2\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "double or \"+inf\" or \"-inf\" string",
          "type": "float|string",
          "options": []
        },
        "end": {
          "comment": "double or \"+inf\" or \"-inf\" string",
          "type": "float|string",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "zDeleteRangeByScore": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "end": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "float",
          "comment": "end"
        }
      }
    },
    "zRemRangeByRank": {
      "access": "public",
      "comment": "Deletes the elements of the sorted set stored at the specified key which have rank in the range [start,end].",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->zAdd('key', 1, 'one');\n$redis->zAdd('key', 2, 'two');\n$redis->zAdd('key', 3, 'three');\n$redis->zRemRangeByRank('key', 0, 1); \/\/ 2\n$redis->zRange('key', 0, -1, array('withscores' => TRUE)); \/\/ array('three' => 3)\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "end": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "end"
        }
      }
    },
    "zDeleteRangeByRank": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "start": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "end": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "int",
          "comment": "end"
        }
      }
    },
    "zCard": {
      "access": "public",
      "comment": "Returns the cardinality of an ordered set.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->zAdd('key', 0, 'val0');\n$redis->zAdd('key', 2, 'val2');\n$redis->zAdd('key', 10, 'val10');\n$redis->zCard('key');            \/\/ 3\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "zSize": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "zScore": {
      "access": "public",
      "comment": "Returns the score of a given member in the specified sorted set.",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis->zAdd('key', 2.5, 'val2');\n$redis->zScore('key', 'val2'); \/\/ 2.5\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "member": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "member"
        }
      }
    },
    "zRank": {
      "access": "public",
      "comment": "Returns the rank of a given member in the specified sorted set, starting at 0 for the item\nwith the smallest score. zRevRank starts at 0 for the item with the largest score.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->delete('z');\n$redis->zAdd('key', 1, 'one');\n$redis->zAdd('key', 2, 'two');\n$redis->zRank('key', 'one');     \/\/ 0\n$redis->zRank('key', 'two');     \/\/ 1\n$redis->zRevRank('key', 'one');  \/\/ 1\n$redis->zRevRank('key', 'two');  \/\/ 0\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "member": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "member"
        }
      }
    },
    "zRevRank": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "int",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "member": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "member"
        }
      }
    },
    "zIncrBy": {
      "access": "public",
      "comment": "Increments the score of a member from a sorted set by a given amount.",
      "isStatic": false,
      "return": "float",
      "example": "\n<pre>\n$redis->delete('key');\n$redis->zIncrBy('key', 2.5, 'member1');  \/\/ key or member1 didn't exist, so member1's score is to 0\n\/\/ before the increment and now has the value 2.5\n$redis->zIncrBy('key', 1, 'member1');    \/\/ 3.5\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "(double) value that will be added to the member's score",
          "type": "float",
          "options": []
        },
        "member": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "member"
        }
      }
    },
    "zUnion": {
      "access": "public",
      "comment": "Creates an union of sorted sets given in second argument.\nThe result of the union will be stored in the sorted set defined by the first argument.\nThe third optionnel argument defines weights to apply to the sorted sets in input.\nIn this case, the weights will be multiplied by the score of each element in the sorted set\nbefore applying the aggregation. The forth argument defines the AGGREGATE option which\nspecify how the results of the union are aggregated.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->delete('k1');\n$redis->delete('k2');\n$redis->delete('k3');\n$redis->delete('ko1');\n$redis->delete('ko2');\n$redis->delete('ko3');\n$redis->zAdd('k1', 0, 'val0');\n$redis->zAdd('k1', 1, 'val1');\n$redis->zAdd('k2', 2, 'val2');\n$redis->zAdd('k2', 3, 'val3');\n$redis->zUnion('ko1', array('k1', 'k2')); \/\/ 4, 'ko1' => array('val0', 'val1', 'val2', 'val3')\n\/\/ Weighted zUnion\n$redis->zUnion('ko2', array('k1', 'k2'), array(1, 1)); \/\/ 4, 'ko2' => array('val0', 'val1', 'val2', 'val3')\n$redis->zUnion('ko3', array('k1', 'k2'), array(5, 1)); \/\/ 4, 'ko3' => array('val0', 'val2', 'val3', 'val1')\n<\/pre>",
      "parameters": {
        "Output": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "ZSetKeys": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "Weights": {
          "comment": "",
          "type": {},
          "options": [],
          "value": null
        },
        "aggregateFunction": {
          "comment": "Either \"SUM\", \"MIN\", or \"MAX\": defines the behaviour to use on",
          "type": "string",
          "options": [],
          "value": "SUM"
        },
        "": {
          "type": "array",
          "comment": "Weights"
        }
      }
    },
    "zInter": {
      "access": "public",
      "comment": "Creates an intersection of sorted sets given in second argument.\nThe result of the union will be stored in the sorted set defined by the first argument.\nThe third optional argument defines weights to apply to the sorted sets in input.\nIn this case, the weights will be multiplied by the score of each element in the sorted set\nbefore applying the aggregation. The forth argument defines the AGGREGATE option which\nspecify how the results of the union are aggregated.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->delete('k1');\n$redis->delete('k2');\n$redis->delete('k3');\n$redis->delete('ko1');\n$redis->delete('ko2');\n$redis->delete('ko3');\n$redis->delete('ko4');\n$redis->zAdd('k1', 0, 'val0');\n$redis->zAdd('k1', 1, 'val1');\n$redis->zAdd('k1', 3, 'val3');\n$redis->zAdd('k2', 2, 'val1');\n$redis->zAdd('k2', 3, 'val3');\n$redis->zInter('ko1', array('k1', 'k2'));               \/\/ 2, 'ko1' => array('val1', 'val3')\n$redis->zInter('ko2', array('k1', 'k2'), array(1, 1));  \/\/ 2, 'ko2' => array('val1', 'val3')\n\/\/ Weighted zInter\n$redis->zInter('ko3', array('k1', 'k2'), array(1, 5), 'min'); \/\/ 2, 'ko3' => array('val1', 'val3')\n$redis->zInter('ko4', array('k1', 'k2'), array(1, 5), 'max'); \/\/ 2, 'ko4' => array('val3', 'val1')\n<\/pre>",
      "parameters": {
        "Output": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "ZSetKeys": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "Weights": {
          "comment": "",
          "type": {},
          "options": [],
          "value": null
        },
        "aggregateFunction": {
          "comment": "Either \"SUM\", \"MIN\", or \"MAX\":",
          "type": "string",
          "options": [],
          "value": "SUM"
        },
        "": {
          "type": "array",
          "comment": "Weights"
        }
      }
    },
    "zScan": {
      "access": "public",
      "comment": "Scan a sorted set for members, with optional pattern and count.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$iterator = null;\nwhile ($members = $redis-zscan('zset', $iterator)) {\nforeach ($members as $member => $score) {\necho $member . ' => ' . $score . PHP_EOL;\n}\n}\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "String, the set to scan.",
          "type": "string",
          "options": []
        },
        "iterator": {
          "comment": "Long (reference), initialized to NULL.",
          "type": "int",
          "options": []
        },
        "pattern": {
          "comment": "String (optional), the pattern to match.",
          "type": "string",
          "options": [],
          "value": null
        },
        "count": {
          "comment": "How many keys to return per iteration (Redis might return a different number).",
          "type": "int",
          "options": [],
          "value": 0
        }
      }
    },
    "hSet": {
      "access": "public",
      "comment": "Adds a value to the hash stored at key. If this value is already in the hash, FALSE is returned.",
      "isStatic": false,
      "return": "0",
      "example": "\n<pre>\n$redis->delete('h')\n$redis->hSet('h', 'key1', 'hello');  \/\/ 1, 'key1' => 'hello' in the hash at \"h\"\n$redis->hGet('h', 'key1');           \/\/ returns \"hello\"\n$redis->hSet('h', 'key1', 'plop');   \/\/ 0, value was replaced.\n$redis->hGet('h', 'key1');           \/\/ returns \"plop\"\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "hashKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "value"
        }
      }
    },
    "hSetNx": {
      "access": "public",
      "comment": "Adds a value to the hash stored at key only if this field isn't already in the hash.",
      "isStatic": false,
      "return": "bool",
      "example": "\n<pre>\n$redis->delete('h')\n$redis->hSetNx('h', 'key1', 'hello'); \/\/ TRUE, 'key1' => 'hello' in the hash at \"h\"\n$redis->hSetNx('h', 'key1', 'world'); \/\/ FALSE, 'key1' => 'hello' in the hash at \"h\". No change since the field\nwasn't replaced.\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "hashKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "value"
        }
      }
    },
    "hGet": {
      "access": "public",
      "comment": "Gets a value from the hash stored at key.\nIf the hash table doesn't exist, or the key doesn't exist, FALSE is returned.",
      "isStatic": false,
      "return": "string",
      "example": "",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "hashKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "hashKey"
        }
      }
    },
    "hLen": {
      "access": "public",
      "comment": "Returns the length of a hash, in number of items",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->delete('h')\n$redis->hSet('h', 'key1', 'hello');\n$redis->hSet('h', 'key2', 'plop');\n$redis->hLen('h'); \/\/ returns 2\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "hDel": {
      "access": "public",
      "comment": "Removes a values from the hash stored at key.\nIf the hash table doesn't exist, or the key doesn't exist, FALSE is returned.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->hMSet('h',\narray(\n'f1' => 'v1',\n'f2' => 'v2',\n'f3' => 'v3',\n'f4' => 'v4',\n));\nvar_dump( $redis->hDel('h', 'f1') );        \/\/ int(1)\nvar_dump( $redis->hDel('h', 'f2', 'f3') );  \/\/ int(2)\ns\nvar_dump( $redis->hGetAll('h') );\n\/\/\/\/ Output:\n\/\/  array(1) {\n\/\/    [\"f4\"]=> string(2) \"v4\"\n\/\/  }\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "hashKey1": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "hashKey2": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "hashKeyN": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": null
        },
        "": {
          "type": "string",
          "comment": "hashKeyN"
        }
      }
    },
    "hKeys": {
      "access": "public",
      "comment": "Returns the keys in a hash, as an array of strings.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$redis->delete('h');\n$redis->hSet('h', 'a', 'x');\n$redis->hSet('h', 'b', 'y');\n$redis->hSet('h', 'c', 'z');\n$redis->hSet('h', 'd', 't');\nvar_dump($redis->hKeys('h'));\n\/\/ Output:\n\/\/ array(4) {\n\/\/ [0]=>\n\/\/ string(1) \"a\"\n\/\/ [1]=>\n\/\/ string(1) \"b\"\n\/\/ [2]=>\n\/\/ string(1) \"c\"\n\/\/ [3]=>\n\/\/ string(1) \"d\"\n\/\/ }\n\/\/ The order is random and corresponds to redis' own internal representation of the set structure.\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "hVals": {
      "access": "public",
      "comment": "Returns the values in a hash, as an array of strings.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$redis->delete('h');\n$redis->hSet('h', 'a', 'x');\n$redis->hSet('h', 'b', 'y');\n$redis->hSet('h', 'c', 'z');\n$redis->hSet('h', 'd', 't');\nvar_dump($redis->hVals('h'));\n\/\/ Output\n\/\/ array(4) {\n\/\/   [0]=>\n\/\/   string(1) \"x\"\n\/\/   [1]=>\n\/\/   string(1) \"y\"\n\/\/   [2]=>\n\/\/   string(1) \"z\"\n\/\/   [3]=>\n\/\/   string(1) \"t\"\n\/\/ }\n\/\/ The order is random and corresponds to redis' own internal representation of the set structure.\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "hGetAll": {
      "access": "public",
      "comment": "Returns the whole hash, as an array of strings indexed by strings.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$redis->delete('h');\n$redis->hSet('h', 'a', 'x');\n$redis->hSet('h', 'b', 'y');\n$redis->hSet('h', 'c', 'z');\n$redis->hSet('h', 'd', 't');\nvar_dump($redis->hGetAll('h'));\n\/\/ Output:\n\/\/ array(4) {\n\/\/   [\"a\"]=>\n\/\/   string(1) \"x\"\n\/\/   [\"b\"]=>\n\/\/   string(1) \"y\"\n\/\/   [\"c\"]=>\n\/\/   string(1) \"z\"\n\/\/   [\"d\"]=>\n\/\/   string(1) \"t\"\n\/\/ }\n\/\/ The order is random and corresponds to redis' own internal representation of the set structure.\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "hExists": {
      "access": "public",
      "comment": "Verify if the specified member exists in a key.",
      "isStatic": false,
      "return": "bool:",
      "example": "\n<pre>\n$redis->hSet('h', 'a', 'x');\n$redis->hExists('h', 'a');               \/\/  TRUE\n$redis->hExists('h', 'NonExistingKey');  \/\/ FALSE\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "hashKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "hashKey"
        }
      }
    },
    "hIncrBy": {
      "access": "public",
      "comment": "Increments the value of a member from a hash by a given amount.",
      "isStatic": false,
      "return": "int",
      "example": "\n<pre>\n$redis->delete('h');\n$redis->hIncrBy('h', 'x', 2); \/\/ returns 2: h[x] = 2 now.\n$redis->hIncrBy('h', 'x', 1); \/\/ h[x] \u2190 2 + 1. Returns 3\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "hashKey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "value": {
          "comment": "(eger) value that will be added to the member's value",
          "type": "int",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "hashKey"
        }
      }
    },
    "hIncrByFloat": {
      "access": "public",
      "comment": "Increment the float value of a hash field by the given amount",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis = new Redis();\n$redis->connect('127.0.0.1');\n$redis->hset('h', 'float', 3);\n$redis->hset('h', 'int',   3);\nvar_dump( $redis->hIncrByFloat('h', 'float', 1.5) ); \/\/ float(4.5)\nvar_dump( $redis->hGetAll('h') );\n\/\/ Output\narray(2) {\n[\"float\"]=>\nstring(3) \"4.5\"\n[\"int\"]=>\nstring(1) \"3\"\n}\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "field": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "increment": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "float",
          "comment": "increment"
        }
      }
    },
    "hMset": {
      "access": "public",
      "comment": "Fills in a whole hash. Non-string values are converted to string, using the standard (string) cast.\nNULL values are stored as empty strings",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis->delete('user:1');\n$redis->hMset('user:1', array('name' => 'Joe', 'salary' => 2000));\n$redis->hIncrBy('user:1', 'salary', 100); \/\/ Joe earns 100 more now.\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "hashKeys": {
          "comment": "key \u2192 value",
          "type": "array",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "hMGet": {
      "access": "public",
      "comment": "Retirieve the values associated to the specified fields in the hash.",
      "isStatic": false,
      "return": "with",
      "example": "\n<pre>\n$redis->delete('h');\n$redis->hSet('h', 'field1', 'value1');\n$redis->hSet('h', 'field2', 'value2');\n$redis->hmGet('h', array('field1', 'field2')); \/\/ returns array('field1' => 'value1', 'field2' => 'value2')\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "hashKeys": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "array",
          "comment": "hashKeys"
        }
      }
    },
    "hScan": {
      "access": "public",
      "comment": "Scan a HASH value for members, with an optional pattern and count.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n\/\/ $iterator = null;\n\/\/ while($elements = $redis->hscan('hash', $iterator)) {\n\/\/     foreach($elements as $key => $value) {\n\/\/         echo $key . ' => ' . $value . PHP_EOL;\n\/\/     }\n\/\/ }\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "iterator": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "pattern": {
          "comment": "Optional pattern to match against.",
          "type": "string",
          "options": [],
          "value": null
        },
        "count": {
          "comment": "How many keys to return in a go (only a sugestion to Redis).",
          "type": "int",
          "options": [],
          "value": 0
        },
        "": {
          "type": "int",
          "comment": "iterator"
        }
      }
    },
    "config": {
      "access": "public",
      "comment": "Get or Set the redis config keys.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$redis->config(\"GET\", \"*max-*-entries*\");\n$redis->config(\"SET\", \"dir\", \"\/var\/run\/redis\/dumps\/\");\n<\/pre>",
      "parameters": {
        "operation": {
          "comment": "either `GET` or `SET`",
          "type": "string",
          "options": []
        },
        "key": {
          "comment": "for `SET`, glob-pattern for `GET`. See http:\/\/redis.io\/commands\/config-get for examples.",
          "type": "string",
          "options": []
        },
        "value": {
          "comment": "optional  (only for `SET`)",
          "type": "string",
          "options": []
        }
      }
    },
    "evaluate": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "mixed",
      "example": "",
      "parameters": {
        "script": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "args": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": []
        },
        "numKeys": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": 0
        },
        "": {
          "type": "int",
          "comment": "numKeys"
        }
      }
    },
    "evalSha": {
      "access": "public",
      "comment": "Evaluate a LUA script serverside, from the SHA1 hash of the script instead of the script itself.\nIn order to run this command Redis will have to have already loaded the script, either by running it or via\nthe SCRIPT LOAD command.",
      "isStatic": false,
      "return": "mixed",
      "example": "\n<pre>\n$script = 'return 1';\n$sha = $redis->script('load', $script);\n$redis->evalSha($sha); \/\/ Returns 1\n<\/pre>",
      "parameters": {
        "scriptSha": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "args": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": []
        },
        "numKeys": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": 0
        },
        "": {
          "type": "int",
          "comment": "numKeys"
        }
      }
    },
    "evaluateSha": {
      "access": "public",
      "comment": "",
      "isStatic": false,
      "return": "",
      "example": "",
      "parameters": {
        "scriptSha": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "args": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": []
        },
        "numKeys": {
          "comment": "",
          "type": "unknown",
          "options": [],
          "value": 0
        },
        "": {
          "type": "int",
          "comment": "numKeys"
        }
      }
    },
    "script": {
      "access": "public",
      "comment": "Execute the Redis SCRIPT command to perform various operations on the scripting subsystem.",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis->script('load', $script);\n$redis->script('flush');\n$redis->script('kill');\n$redis->script('exists', $script1, [$script2, $script3, ...]);\n<\/pre>\nSCRIPT LOAD will return the SHA1 hash of the passed script on success, and FALSE on failure.\nSCRIPT FLUSH should always return TRUE\nSCRIPT KILL will return true if a script was able to be killed and false if not\nSCRIPT EXISTS will return an array with TRUE or FALSE for each passed script",
      "parameters": {
        "command": {
          "comment": "load | flush | kill | exists",
          "type": "string",
          "options": []
        },
        "script": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "script"
        }
      }
    },
    "getLastError": {
      "access": "public",
      "comment": "The last error message (if any)",
      "isStatic": false,
      "return": "string",
      "example": "\n<pre>\n$redis->eval('this-is-not-lua');\n$err = $redis->getLastError();\n\/\/ \"ERR Error compiling script (new function): user_script:1: '=' expected near '-'\"\n<\/pre>",
      "parameters": []
    },
    "clearLastError": {
      "access": "public",
      "comment": "Clear the last error message",
      "isStatic": false,
      "return": "bool",
      "example": "\n<pre>\n$redis->set('x', 'a');\n$redis->incr('x');\n$err = $redis->getLastError();\n\/\/ \"ERR value is not an integer or out of range\"\n$redis->clearLastError();\n$err = $redis->getLastError();\n\/\/ NULL\n<\/pre>",
      "parameters": []
    },
    "_prefix": {
      "access": "public",
      "comment": "A utility method to prefix the value with the prefix setting for phpredis.",
      "isStatic": false,
      "return": "string",
      "example": "\n<pre>\n$redis->setOption(Redis::OPT_PREFIX, 'my-prefix:');\n$redis->_prefix('my-value'); \/\/ Will return 'my-prefix:my-value'\n<\/pre>",
      "parameters": {
        "value": {
          "comment": "The value you wish to prefix",
          "type": "mixed",
          "options": []
        }
      }
    },
    "_unserialize": {
      "access": "public",
      "comment": "A utility method to unserialize data with whatever serializer is set up.  If there is no serializer set, the\nvalue will be returned unchanged.  If there is a serializer set up, and the data passed in is malformed, an\nexception will be thrown. This can be useful if phpredis is serializing values, and you return something from\nredis in a LUA script that is serialized.",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP);\n$redis->_unserialize('a:3:{i:0;i:1;i:1;i:2;i:2;i:3;}'); \/\/ Will return Array(1,2,3)\n<\/pre>",
      "parameters": {
        "value": {
          "comment": "The value to be unserialized",
          "type": "string",
          "options": []
        }
      }
    },
    "_serialize": {
      "access": "public",
      "comment": "A utility method to serialize values manually. This method allows you to serialize a value with whatever\nserializer is configured, manually. This can be useful for serialization\/unserialization of data going in\nand out of EVAL commands as phpredis can't automatically do this itself.  Note that if no serializer is\nset, phpredis will change Array values to 'Array', and Objects to 'Object'.",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_NONE);\n$redis->_serialize(\"foo\"); \/\/ returns \"foo\"\n$redis->_serialize(Array()); \/\/ Returns \"Array\"\n$redis->_serialize(new stdClass()); \/\/ Returns \"Object\"\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP);\n$redis->_serialize(\"foo\"); \/\/ Returns 's:3:\"foo\";'\n<\/pre>",
      "parameters": {
        "value": {
          "comment": "The value to be serialized.",
          "type": "mixed",
          "options": []
        }
      }
    },
    "dump": {
      "access": "public",
      "comment": "Dump a key out of a redis database, the value of which can later be passed into redis using the RESTORE command.\nThe data that comes out of DUMP is a binary representation of the key as Redis stores it.",
      "isStatic": false,
      "return": "string",
      "example": "\n<pre>\n$redis->set('foo', 'bar');\n$val = $redis->dump('foo'); \/\/ $val will be the Redis encoded key value\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string",
          "comment": "key"
        }
      }
    },
    "restore": {
      "access": "public",
      "comment": "Restore a key from the result of a DUMP operation.",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis->set('foo', 'bar');\n$val = $redis->dump('foo');\n$redis->restore('bar', 0, $val); \/\/ The key 'bar', will now be equal to the key 'foo'\n<\/pre>",
      "parameters": {
        "key": {
          "comment": "The key name",
          "type": "string",
          "options": []
        },
        "ttl": {
          "comment": "How long the key should live (if zero, no expire will be set on the key)",
          "type": "int",
          "options": []
        },
        "value": {
          "comment": "(binary).  The Redis encoded key value (from DUMP)",
          "type": "string",
          "options": []
        }
      }
    },
    "migrate": {
      "access": "public",
      "comment": "Migrates a key to a different Redis instance.",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis->migrate('backup', 6379, 'foo', 0, 3600);\n<\/pre>",
      "parameters": {
        "host": {
          "comment": "The destination host",
          "type": "string",
          "options": []
        },
        "port": {
          "comment": "The TCP port to connect to.",
          "type": "int",
          "options": []
        },
        "key": {
          "comment": "The key to migrate.",
          "type": "string",
          "options": []
        },
        "db": {
          "comment": "The target DB.",
          "type": "int",
          "options": []
        },
        "timeout": {
          "comment": "The maximum amount of time given to this transfer.",
          "type": "int",
          "options": []
        },
        "copy": {
          "comment": "Should we send the COPY flag to redis.",
          "type": "bool",
          "options": [],
          "value": false
        },
        "replace": {
          "comment": "Should we send the REPLACE flag to redis.",
          "type": "bool",
          "options": [],
          "value": false
        }
      }
    },
    "time": {
      "access": "public",
      "comment": "Return the current Redis server time.",
      "isStatic": false,
      "return": "unix",
      "example": "\n<pre>\nvar_dump( $redis->time() );\n\/\/ array(2) {\n\/\/   [0] => string(10) \"1342364352\"\n\/\/   [1] => string(6) \"253002\"\n\/\/ }\n<\/pre>",
      "parameters": []
    },
    "scan": {
      "access": "public",
      "comment": "Scan the keyspace for keys.",
      "isStatic": false,
      "return": "array",
      "example": "\n<pre>\n$iterator = null;\nwhile($keys = $redis->scan($iterator)) {\nforeach($keys as $key) {\necho $key . PHP_EOL;\n}\n}\n<\/pre>",
      "parameters": {
        "iterator": {
          "comment": "Iterator, initialized to NULL.",
          "type": "int",
          "options": []
        },
        "pattern": {
          "comment": "Pattern to match.",
          "type": "string",
          "options": [],
          "value": null
        },
        "count": {
          "comment": "Count of keys per iteration (only a suggestion to Redis).",
          "type": "int",
          "options": [],
          "value": 0
        }
      }
    },
    "pfAdd": {
      "access": "public",
      "comment": "Adds all the element arguments to the HyperLogLog data structure stored at the key.",
      "isStatic": false,
      "return": "",
      "example": "$redis->pfAdd('key', array('elem1', 'elem2'))",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "elements": {
          "comment": "",
          "type": {},
          "options": []
        },
        "": {
          "type": "array",
          "comment": "elements"
        }
      }
    },
    "pfCount": {
      "access": "public",
      "comment": "When called with a single key, returns the approximated cardinality computed by the HyperLogLog data\nstructure stored at the specified variable, which is 0 if the variable does not exist.",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis->pfAdd('key1', array('elem1', 'elem2'));\n$redis->pfAdd('key2', array('elem3', 'elem2'));\n$redis->pfCount('key1'); \/\/ int(2)\n$redis->pfCount(array('key1', 'key2')); \/\/ int(3)",
      "parameters": {
        "key": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "": {
          "type": "string|array",
          "comment": "key"
        }
      }
    },
    "pfMerge": {
      "access": "public",
      "comment": "Merge multiple HyperLogLog values into an unique value that will approximate the cardinality\nof the union of the observed Sets of the source HyperLogLog structures.",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis->pfAdd('key1', array('elem1', 'elem2'));\n$redis->pfAdd('key2', array('elem3', 'elem2'));\n$redis->pfMerge('key3', array('key1', 'key2'));\n$redis->pfCount('key3'); \/\/ int(3)",
      "parameters": {
        "destkey": {
          "comment": "",
          "type": "unknown",
          "options": []
        },
        "sourcekeys": {
          "comment": "",
          "type": {},
          "options": []
        },
        "": {
          "type": "array",
          "comment": "sourcekeys"
        }
      }
    },
    "rawCommand": {
      "access": "public",
      "comment": "Send arbitrary things to the redis server.",
      "isStatic": false,
      "return": "",
      "example": "\n<pre>\n$redis->rawCommand('SET', 'key', 'value'); \/\/ bool(true)\n$redis->rawCommand('GET\", 'key'); \/\/ string(5) \"value\"\n<\/pre>",
      "parameters": {
        "command": {
          "comment": "Required command to send to the server.",
          "type": "string",
          "options": []
        },
        "arguments": {
          "comment": "Optional variable amount of arguments to send to the server.",
          "type": "mixed,...",
          "options": []
        }
      }
    },
    "getMode": {
      "access": "public",
      "comment": "Detect whether we're in ATOMIC\/MULTI\/PIPELINE mode.",
      "isStatic": false,
      "return": "int",
      "example": "$redis->getMode();",
      "parameters": []
    }
  }
}